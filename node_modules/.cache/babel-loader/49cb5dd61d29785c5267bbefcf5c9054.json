{"ast":null,"code":"var _excluded = [\"children\", \"errors\", \"infos\", \"messages\", \"onChange\", \"onReset\", \"onSubmit\", \"onValidate\", \"validate\", \"value\"];\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nimport React, { forwardRef, useCallback, useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport { MessageContext } from '../../contexts/MessageContext';\nimport { FormContext } from './FormContext';\nimport { FormPropTypes } from './propTypes';\nvar defaultValue = {};\nvar defaultTouched = {};\nvar defaultValidationResults = {\n  errors: {},\n  infos: {}\n}; // Validating nameValues with the validator and sending correct messaging\n\nvar validate = function validate(validator, nameValue, formValue, format, messages) {\n  var result;\n\n  if (typeof validator === 'function') {\n    result = validator(nameValue, formValue);\n  } else if (validator.regexp) {\n    if (!validator.regexp.test(nameValue)) {\n      result = validator.message || format({\n        id: 'form.invalid',\n        messages: messages\n      });\n\n      if (validator.status) {\n        result = {\n          message: result,\n          status: validator.status\n        };\n      }\n    }\n  }\n\n  return result;\n}; // Validates particular key in formValue\n\n\nvar validateName = function validateName(nameValidators, required) {\n  return function (name, formValue, format, messages) {\n    var nameValue = formValue[name];\n    var result; // ValidateArg is something that gets passed in from a FormField component\n    // See 'validate' prop in FormField\n\n    if (required && (nameValue === undefined || nameValue === '' || nameValue === false || Array.isArray(nameValue) && !nameValue.length)) {\n      // There is no value at that name, and one is required\n      result = format({\n        id: 'form.required',\n        messages: messages\n      });\n    } else if (nameValidators) {\n      if (Array.isArray(nameValidators)) {\n        nameValidators.some(function (validator) {\n          result = validate(validator, nameValue, formValue, format, messages);\n          return !!result;\n        });\n      } else {\n        result = validate(nameValidators, nameValue, formValue, format, messages);\n      }\n    }\n\n    return result;\n  };\n}; // validations is an array from Object.entries()\n// Validates all keys in formValue\n\n\nvar validateForm = function validateForm(validations, formValue, format, messages, omitValid) {\n  var nextErrors = {};\n  var nextInfos = {};\n  validations.forEach(function (_ref) {\n    var name = _ref[0],\n        _ref$ = _ref[1],\n        field = _ref$.field,\n        input = _ref$.input;\n\n    if (!omitValid) {\n      nextErrors[name] = undefined;\n      nextInfos[name] = undefined;\n    }\n\n    var result;\n\n    if (input) {\n      // input() are validations supplied through useFormInput()\n      result = input(name, formValue, format, messages);\n    }\n\n    if (field && !result) {\n      // field() are validations supplied through useFormField()\n      result = field(name, formValue, format, messages);\n    } // typeof error === 'object' is implied for both cases of error with\n    // a status message and for an error object that is a react node\n\n\n    if (typeof result === 'object') {\n      if (result.status === 'info') {\n        nextInfos[name] = result.message;\n      } else {\n        nextErrors[name] = result.message || result; // could be a node\n      }\n    } else if (typeof result === 'string') {\n      nextErrors[name] = result;\n    }\n  });\n  return [nextErrors, nextInfos];\n};\n\nvar Form = /*#__PURE__*/forwardRef(function (_ref2, ref) {\n  var children = _ref2.children,\n      _ref2$errors = _ref2.errors,\n      errorsProp = _ref2$errors === void 0 ? defaultValidationResults.errors : _ref2$errors,\n      _ref2$infos = _ref2.infos,\n      infosProp = _ref2$infos === void 0 ? defaultValidationResults.infos : _ref2$infos,\n      messages = _ref2.messages,\n      onChange = _ref2.onChange,\n      _onReset = _ref2.onReset,\n      _onSubmit = _ref2.onSubmit,\n      onValidate = _ref2.onValidate,\n      _ref2$validate = _ref2.validate,\n      validateOn = _ref2$validate === void 0 ? 'submit' : _ref2$validate,\n      valueProp = _ref2.value,\n      rest = _objectWithoutPropertiesLoose(_ref2, _excluded);\n\n  var _useContext = useContext(MessageContext),\n      format = _useContext.format;\n\n  var _useState = useState(valueProp || defaultValue),\n      valueState = _useState[0],\n      setValueState = _useState[1];\n\n  var value = useMemo(function () {\n    return valueProp || valueState;\n  }, [valueProp, valueState]);\n\n  var _useState2 = useState(defaultTouched),\n      touched = _useState2[0],\n      setTouched = _useState2[1];\n\n  var _useState3 = useState(defaultValidationResults),\n      validationResults = _useState3[0],\n      setValidationResults = _useState3[1]; // when onBlur input validation is triggered, we need to complete any\n  // potential click events before running the onBlur validation.\n  // otherwise, click events like reset, etc. may not be registered.\n  // for a detailed scenario/discussion,\n  // see: https://github.com/grommet/grommet/issues/4863\n  // the value of pendingValidation is the name of the FormField\n  // awaiting validation.\n\n\n  var _useState4 = useState(undefined),\n      pendingValidation = _useState4[0],\n      setPendingValidation = _useState4[1];\n\n  useEffect(function () {\n    setPendingValidation(undefined);\n    setValidationResults({\n      errors: errorsProp,\n      infos: infosProp\n    });\n  }, [errorsProp, infosProp]);\n  var validations = useRef({});\n  var requiredFields = useRef([]);\n  var buildValid = useCallback(function (nextErrors) {\n    var valid = false;\n    valid = requiredFields.current.filter(function (n) {\n      return Object.keys(validations.current).includes(n);\n    }).every(function (field) {\n      return value[field] && (value[field] !== '' || value[field] !== false);\n    });\n    if (Object.keys(nextErrors).length > 0) valid = false;\n    return valid;\n  }, [value]); // Remove any errors that we don't have any validations for anymore.\n\n  var filterErrorValidations = function filterErrorValidations(errors) {\n    var nextErrors = errors;\n    return Object.keys(nextErrors).filter(function (n) {\n      return !validations.current[n] || nextErrors[n] === undefined;\n    }).forEach(function (n) {\n      return delete nextErrors[n];\n    });\n  }; // Remove any infos that we don't have any validations for anymore.\n\n\n  var filterInfoValidations = function filterInfoValidations(infos) {\n    var nextInfos = infos;\n    return Object.keys(nextInfos).filter(function (n) {\n      return !validations.current[n] || nextInfos[n] === undefined;\n    }).forEach(function (n) {\n      return delete nextInfos[n];\n    });\n  }; // On initial mount, when validateOn is change or blur,\n  // set validation results for any set fields and calculate whether\n  // the form is valid overall.\n\n\n  useEffect(function () {\n    var validationsForSetFields = Object.entries(validations.current).filter(function (_ref3) {\n      var n = _ref3[0];\n      return value[n];\n    });\n\n    if (validationsForSetFields.length > 0 && validateOn !== 'submit') {\n      var _validateForm = validateForm(validationsForSetFields, value, format, messages),\n          errors = _validateForm[0],\n          infos = _validateForm[1];\n\n      filterErrorValidations(errors);\n      filterInfoValidations(infos);\n      var nextValidationResults = {\n        errors: errors,\n        infos: infos,\n        valid: buildValid(errors)\n      };\n      if (onValidate) onValidate(nextValidationResults);\n      setValidationResults(nextValidationResults);\n    } // We only want to run this for the value we have on initial mount.\n    // We don't want subsequent changes to the value to re-run this.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []); // Currently, onBlur validation will trigger after a timeout of 120ms.\n\n  useEffect(function () {\n    var timer = setTimeout(function () {\n      if (pendingValidation) {\n        // run validations on the pending one and any other touched fields\n        var _validateForm2 = validateForm(Object.entries(validations.current).filter(function (_ref4) {\n          var n = _ref4[0];\n          return touched[n] || pendingValidation.includes(n);\n        }), value, format, messages),\n            validatedErrors = _validateForm2[0],\n            validatedInfos = _validateForm2[1];\n\n        setPendingValidation(undefined);\n        setValidationResults(function (prevValidationResults) {\n          // keep any previous errors and infos for untouched keys,\n          // these may have come from a submit\n          var nextErrors = _extends({}, prevValidationResults.errors, validatedErrors);\n\n          var nextInfos = _extends({}, prevValidationResults.infos, validatedInfos);\n\n          filterErrorValidations(nextErrors);\n          filterInfoValidations(nextInfos);\n          var nextValidationResults = {\n            errors: nextErrors,\n            infos: nextInfos,\n            valid: buildValid(nextErrors)\n          };\n          if (onValidate) onValidate(nextValidationResults);\n          return nextValidationResults;\n        });\n      } // a timeout is needed to ensure that a click event (like one on a reset\n      // button) completes prior to running the validation. without a timeout,\n      // the blur will always complete and trigger a validation prematurely\n      // The following values have been empirically tested, but 120 was\n      // selected because it is the largest value\n      // Chrome: 100, Safari: 120, Firefox: 80\n\n    }, 120);\n    return function () {\n      return clearTimeout(timer);\n    };\n  }, [buildValid, format, messages, pendingValidation, onValidate, touched, value, requiredFields]); // clear any errors when value changes\n\n  useEffect(function () {\n    if (validateOn !== 'change') setPendingValidation(undefined);\n    setValidationResults(function (prevValidationResults) {\n      var _validateForm3 = validateForm(Object.entries(validations.current).filter(function (_ref5) {\n        var n = _ref5[0];\n        return prevValidationResults.errors[n] || prevValidationResults.infos[n];\n      }), value, format, messages),\n          nextErrors = _validateForm3[0],\n          nextInfos = _validateForm3[1];\n\n      return {\n        errors: _extends({}, prevValidationResults.errors, nextErrors),\n        infos: _extends({}, prevValidationResults.infos, nextInfos)\n      };\n    });\n  }, [format, messages, touched, validateOn, value]); // There are three basic patterns of handling form input value state:\n  //\n  // 1 - form controlled\n  //\n  // In this model, the caller sets `value` and `onChange` properties\n  // on the Form component to supply the values used by the input fields.\n  // In useFormContext(), componentValue would be undefined and formValue\n  // is be set to whatever the form state has. Whenever the form state\n  // changes, we update the contextValue so the input component will use\n  // that. When the input component changes, we will call update() to\n  // update the form state.\n  //\n  // 2 - input controlled\n  //\n  // In this model, the caller sets `value` and `onChange` properties\n  // on the input components, like TextInput, to supply the value for it.\n  // In useFormContext(), componentValue is this value and we ensure to\n  // update the form state, via update(), and set the contextValue from\n  // the componentValue. When the input component changes, we will\n  // call update() to update the form state.\n  //\n  // 3 - uncontrolled\n  //\n  // In this model, the caller doesn't set a `value` or `onChange` property\n  // at either the form or input component levels.\n  // In useFormContext(), componentValue is undefined and valueProp is\n  // undefined and nothing much happens here. That is, unless the\n  // calling component needs to know the state in order to work, such\n  // as CheckBox or Select. In this case, those components supply\n  // an initialValue, which will trigger updating the contextValue so\n  // they can have access to it.\n  //\n\n  var useFormInput = function useFormInput(_ref6) {\n    var name = _ref6.name,\n        componentValue = _ref6.value,\n        initialValue = _ref6.initialValue,\n        validateArg = _ref6.validate;\n\n    var _useState5 = useState(initialValue),\n        inputValue = _useState5[0],\n        setInputValue = _useState5[1];\n\n    var formValue = name ? value[name] : undefined; // for dynamic forms, we need to track when an input has been added to\n    // the form value. if the input is unmounted, we will delete its key/value\n    // from the form value.\n\n    var keyCreated = useRef(false); // This effect is for pattern #2, where the controlled input\n    // component is driving the value via componentValue.\n\n    useEffect(function () {\n      if (name && // we have somewhere to put this\n      componentValue !== undefined && // input driving\n      componentValue !== formValue // don't already have it\n      ) {\n        setValueState(function (prevValue) {\n          var nextValue = _extends({}, prevValue);\n\n          nextValue[name] = componentValue;\n          return nextValue;\n        }); // don't onChange on programmatic changes\n      }\n    }, [componentValue, formValue, name]); // on unmount, if the form is uncontrolled, remove the key/value\n    // from the form value\n\n    useEffect(function () {\n      return function () {\n        if (keyCreated.current) {\n          keyCreated.current = false;\n          setValueState(function (prevValue) {\n            var nextValue = _extends({}, prevValue);\n\n            delete nextValue[name];\n            return nextValue;\n          });\n        }\n      };\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    [] // only run onmount and unmount\n    );\n    useEffect(function () {\n      if (validateArg) {\n        if (!validations.current[name]) {\n          validations.current[name] = {};\n        }\n\n        validations.current[name].input = validateName(validateArg);\n        return function () {\n          return delete validations.current[name].input;\n        };\n      }\n\n      return undefined;\n    }, [validateArg, name]);\n    var useValue;\n    if (componentValue !== undefined) // input component drives, pattern #2\n      useValue = componentValue;else if (valueProp && name && formValue !== undefined) // form drives, pattern #1\n      useValue = formValue;else if (formValue === undefined && name) // form has reset, so reset input value as well\n      useValue = initialValue;else useValue = inputValue;\n    return [useValue, function (nextComponentValue) {\n      if (name) {\n        // we have somewhere to put this\n        var nextTouched = _extends({}, touched);\n\n        nextTouched[name] = true;\n\n        if (!touched[name]) {\n          // don't update if not needed\n          setTouched(nextTouched);\n        }\n\n        var nextValue = _extends({}, value); // if nextValue doesn't have a key for name, this must be\n        // uncontrolled form. we will flag this field was added so\n        // we know to remove its value from the form if it is dynamically\n        // removed\n\n\n        if (!(name in nextValue)) keyCreated.current = true;\n        nextValue[name] = nextComponentValue;\n        setValueState(nextValue);\n        if (onChange) onChange(nextValue, {\n          touched: nextTouched\n        });\n      }\n\n      if (initialValue !== undefined) setInputValue(nextComponentValue);\n    }];\n  };\n\n  var useFormField = function useFormField(_ref7) {\n    var errorArg = _ref7.error,\n        infoArg = _ref7.info,\n        name = _ref7.name,\n        required = _ref7.required,\n        disabled = _ref7.disabled,\n        validateArg = _ref7.validate;\n    var error = disabled ? undefined : errorArg || validationResults.errors[name];\n    var info = infoArg || validationResults.infos[name];\n    useEffect(function () {\n      var index = requiredFields.current.indexOf(name);\n\n      if (required) {\n        if (index === -1) requiredFields.current.push(name);\n      } else if (index !== -1) requiredFields.current.splice(index, 1);\n\n      if (validateArg || required) {\n        if (!validations.current[name]) {\n          validations.current[name] = {};\n        }\n\n        validations.current[name].field = validateName(validateArg, required);\n        return function () {\n          return delete validations.current[name].field;\n        };\n      }\n\n      return undefined;\n    }, [error, name, required, validateArg, disabled]);\n    return {\n      error: error,\n      info: info,\n      inForm: true,\n      onBlur: validateOn === 'blur' ? function () {\n        return setPendingValidation(pendingValidation ? [].concat(pendingValidation, [name]) : [name]);\n      } : undefined,\n      onChange: validateOn === 'change' ? function () {\n        return setPendingValidation(pendingValidation ? [].concat(pendingValidation, [name]) : [name]);\n      } : undefined\n    };\n  };\n\n  return /*#__PURE__*/React.createElement(\"form\", _extends({\n    ref: ref\n  }, rest, {\n    onReset: function onReset(event) {\n      setPendingValidation(undefined);\n\n      if (!valueProp) {\n        setValueState(defaultValue);\n        if (onChange) onChange(defaultValue, {\n          touched: defaultTouched\n        });\n      }\n\n      setTouched(defaultTouched);\n      setValidationResults(defaultValidationResults);\n\n      if (_onReset) {\n        event.persist(); // extract from React's synthetic event pool\n\n        var adjustedEvent = event;\n        adjustedEvent.value = defaultValue;\n\n        _onReset(adjustedEvent);\n      }\n    },\n    onSubmit: function onSubmit(event) {\n      // Don't submit the form via browser form action. We don't want it\n      // if the validation fails. And, we assume a javascript action handler\n      // otherwise.\n      event.preventDefault();\n      setPendingValidation(undefined);\n\n      var _validateForm4 = validateForm(Object.entries(validations.current), value, format, messages, true),\n          nextErrors = _validateForm4[0],\n          nextInfos = _validateForm4[1];\n\n      setValidationResults(function () {\n        var nextValidationResults = {\n          errors: nextErrors,\n          infos: nextInfos,\n          // Show form's validity when clicking on Submit\n          valid: buildValid(nextErrors)\n        };\n        if (onValidate) onValidate(nextValidationResults);\n        return nextValidationResults;\n      });\n\n      if (Object.keys(nextErrors).length === 0 && _onSubmit) {\n        event.persist(); // extract from React's synthetic event pool\n\n        var adjustedEvent = event;\n        adjustedEvent.value = value;\n        adjustedEvent.touched = touched;\n\n        _onSubmit(adjustedEvent);\n      }\n    }\n  }), /*#__PURE__*/React.createElement(FormContext.Provider, {\n    value: {\n      useFormField: useFormField,\n      useFormInput: useFormInput\n    }\n  }, children));\n});\nForm.displayName = 'Form';\nForm.propTypes = FormPropTypes;\nexport { Form };","map":{"version":3,"sources":["/Users/rachel/workout-generator/node_modules/grommet/es6/components/Form/Form.js"],"names":["_excluded","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","_objectWithoutPropertiesLoose","excluded","sourceKeys","keys","indexOf","React","forwardRef","useCallback","useContext","useEffect","useMemo","useRef","useState","MessageContext","FormContext","FormPropTypes","defaultValue","defaultTouched","defaultValidationResults","errors","infos","validate","validator","nameValue","formValue","format","messages","result","regexp","test","message","id","status","validateName","nameValidators","required","name","undefined","Array","isArray","some","validateForm","validations","omitValid","nextErrors","nextInfos","forEach","_ref","_ref$","field","input","Form","_ref2","ref","children","_ref2$errors","errorsProp","_ref2$infos","infosProp","onChange","_onReset","onReset","_onSubmit","onSubmit","onValidate","_ref2$validate","validateOn","valueProp","value","rest","_useContext","_useState","valueState","setValueState","_useState2","touched","setTouched","_useState3","validationResults","setValidationResults","_useState4","pendingValidation","setPendingValidation","requiredFields","buildValid","valid","current","filter","n","includes","every","filterErrorValidations","filterInfoValidations","validationsForSetFields","entries","_ref3","_validateForm","nextValidationResults","timer","setTimeout","_validateForm2","_ref4","validatedErrors","validatedInfos","prevValidationResults","clearTimeout","_validateForm3","_ref5","useFormInput","_ref6","componentValue","initialValue","validateArg","_useState5","inputValue","setInputValue","keyCreated","prevValue","nextValue","useValue","nextComponentValue","nextTouched","useFormField","_ref7","errorArg","error","infoArg","info","disabled","index","push","splice","inForm","onBlur","concat","createElement","event","persist","adjustedEvent","preventDefault","_validateForm4","Provider","displayName","propTypes"],"mappings":"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","sourcesContent":["var _excluded = [\"children\", \"errors\", \"infos\", \"messages\", \"onChange\", \"onReset\", \"onSubmit\", \"onValidate\", \"validate\", \"value\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React, { forwardRef, useCallback, useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport { MessageContext } from '../../contexts/MessageContext';\nimport { FormContext } from './FormContext';\nimport { FormPropTypes } from './propTypes';\nvar defaultValue = {};\nvar defaultTouched = {};\nvar defaultValidationResults = {\n  errors: {},\n  infos: {}\n}; // Validating nameValues with the validator and sending correct messaging\n\nvar validate = function validate(validator, nameValue, formValue, format, messages) {\n  var result;\n\n  if (typeof validator === 'function') {\n    result = validator(nameValue, formValue);\n  } else if (validator.regexp) {\n    if (!validator.regexp.test(nameValue)) {\n      result = validator.message || format({\n        id: 'form.invalid',\n        messages: messages\n      });\n\n      if (validator.status) {\n        result = {\n          message: result,\n          status: validator.status\n        };\n      }\n    }\n  }\n\n  return result;\n}; // Validates particular key in formValue\n\n\nvar validateName = function validateName(nameValidators, required) {\n  return function (name, formValue, format, messages) {\n    var nameValue = formValue[name];\n    var result; // ValidateArg is something that gets passed in from a FormField component\n    // See 'validate' prop in FormField\n\n    if (required && (nameValue === undefined || nameValue === '' || nameValue === false || Array.isArray(nameValue) && !nameValue.length)) {\n      // There is no value at that name, and one is required\n      result = format({\n        id: 'form.required',\n        messages: messages\n      });\n    } else if (nameValidators) {\n      if (Array.isArray(nameValidators)) {\n        nameValidators.some(function (validator) {\n          result = validate(validator, nameValue, formValue, format, messages);\n          return !!result;\n        });\n      } else {\n        result = validate(nameValidators, nameValue, formValue, format, messages);\n      }\n    }\n\n    return result;\n  };\n}; // validations is an array from Object.entries()\n// Validates all keys in formValue\n\n\nvar validateForm = function validateForm(validations, formValue, format, messages, omitValid) {\n  var nextErrors = {};\n  var nextInfos = {};\n  validations.forEach(function (_ref) {\n    var name = _ref[0],\n        _ref$ = _ref[1],\n        field = _ref$.field,\n        input = _ref$.input;\n\n    if (!omitValid) {\n      nextErrors[name] = undefined;\n      nextInfos[name] = undefined;\n    }\n\n    var result;\n\n    if (input) {\n      // input() are validations supplied through useFormInput()\n      result = input(name, formValue, format, messages);\n    }\n\n    if (field && !result) {\n      // field() are validations supplied through useFormField()\n      result = field(name, formValue, format, messages);\n    } // typeof error === 'object' is implied for both cases of error with\n    // a status message and for an error object that is a react node\n\n\n    if (typeof result === 'object') {\n      if (result.status === 'info') {\n        nextInfos[name] = result.message;\n      } else {\n        nextErrors[name] = result.message || result; // could be a node\n      }\n    } else if (typeof result === 'string') {\n      nextErrors[name] = result;\n    }\n  });\n  return [nextErrors, nextInfos];\n};\n\nvar Form = /*#__PURE__*/forwardRef(function (_ref2, ref) {\n  var children = _ref2.children,\n      _ref2$errors = _ref2.errors,\n      errorsProp = _ref2$errors === void 0 ? defaultValidationResults.errors : _ref2$errors,\n      _ref2$infos = _ref2.infos,\n      infosProp = _ref2$infos === void 0 ? defaultValidationResults.infos : _ref2$infos,\n      messages = _ref2.messages,\n      onChange = _ref2.onChange,\n      _onReset = _ref2.onReset,\n      _onSubmit = _ref2.onSubmit,\n      onValidate = _ref2.onValidate,\n      _ref2$validate = _ref2.validate,\n      validateOn = _ref2$validate === void 0 ? 'submit' : _ref2$validate,\n      valueProp = _ref2.value,\n      rest = _objectWithoutPropertiesLoose(_ref2, _excluded);\n\n  var _useContext = useContext(MessageContext),\n      format = _useContext.format;\n\n  var _useState = useState(valueProp || defaultValue),\n      valueState = _useState[0],\n      setValueState = _useState[1];\n\n  var value = useMemo(function () {\n    return valueProp || valueState;\n  }, [valueProp, valueState]);\n\n  var _useState2 = useState(defaultTouched),\n      touched = _useState2[0],\n      setTouched = _useState2[1];\n\n  var _useState3 = useState(defaultValidationResults),\n      validationResults = _useState3[0],\n      setValidationResults = _useState3[1]; // when onBlur input validation is triggered, we need to complete any\n  // potential click events before running the onBlur validation.\n  // otherwise, click events like reset, etc. may not be registered.\n  // for a detailed scenario/discussion,\n  // see: https://github.com/grommet/grommet/issues/4863\n  // the value of pendingValidation is the name of the FormField\n  // awaiting validation.\n\n\n  var _useState4 = useState(undefined),\n      pendingValidation = _useState4[0],\n      setPendingValidation = _useState4[1];\n\n  useEffect(function () {\n    setPendingValidation(undefined);\n    setValidationResults({\n      errors: errorsProp,\n      infos: infosProp\n    });\n  }, [errorsProp, infosProp]);\n  var validations = useRef({});\n  var requiredFields = useRef([]);\n  var buildValid = useCallback(function (nextErrors) {\n    var valid = false;\n    valid = requiredFields.current.filter(function (n) {\n      return Object.keys(validations.current).includes(n);\n    }).every(function (field) {\n      return value[field] && (value[field] !== '' || value[field] !== false);\n    });\n    if (Object.keys(nextErrors).length > 0) valid = false;\n    return valid;\n  }, [value]); // Remove any errors that we don't have any validations for anymore.\n\n  var filterErrorValidations = function filterErrorValidations(errors) {\n    var nextErrors = errors;\n    return Object.keys(nextErrors).filter(function (n) {\n      return !validations.current[n] || nextErrors[n] === undefined;\n    }).forEach(function (n) {\n      return delete nextErrors[n];\n    });\n  }; // Remove any infos that we don't have any validations for anymore.\n\n\n  var filterInfoValidations = function filterInfoValidations(infos) {\n    var nextInfos = infos;\n    return Object.keys(nextInfos).filter(function (n) {\n      return !validations.current[n] || nextInfos[n] === undefined;\n    }).forEach(function (n) {\n      return delete nextInfos[n];\n    });\n  }; // On initial mount, when validateOn is change or blur,\n  // set validation results for any set fields and calculate whether\n  // the form is valid overall.\n\n\n  useEffect(function () {\n    var validationsForSetFields = Object.entries(validations.current).filter(function (_ref3) {\n      var n = _ref3[0];\n      return value[n];\n    });\n\n    if (validationsForSetFields.length > 0 && validateOn !== 'submit') {\n      var _validateForm = validateForm(validationsForSetFields, value, format, messages),\n          errors = _validateForm[0],\n          infos = _validateForm[1];\n\n      filterErrorValidations(errors);\n      filterInfoValidations(infos);\n      var nextValidationResults = {\n        errors: errors,\n        infos: infos,\n        valid: buildValid(errors)\n      };\n      if (onValidate) onValidate(nextValidationResults);\n      setValidationResults(nextValidationResults);\n    } // We only want to run this for the value we have on initial mount.\n    // We don't want subsequent changes to the value to re-run this.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []); // Currently, onBlur validation will trigger after a timeout of 120ms.\n\n  useEffect(function () {\n    var timer = setTimeout(function () {\n      if (pendingValidation) {\n        // run validations on the pending one and any other touched fields\n        var _validateForm2 = validateForm(Object.entries(validations.current).filter(function (_ref4) {\n          var n = _ref4[0];\n          return touched[n] || pendingValidation.includes(n);\n        }), value, format, messages),\n            validatedErrors = _validateForm2[0],\n            validatedInfos = _validateForm2[1];\n\n        setPendingValidation(undefined);\n        setValidationResults(function (prevValidationResults) {\n          // keep any previous errors and infos for untouched keys,\n          // these may have come from a submit\n          var nextErrors = _extends({}, prevValidationResults.errors, validatedErrors);\n\n          var nextInfos = _extends({}, prevValidationResults.infos, validatedInfos);\n\n          filterErrorValidations(nextErrors);\n          filterInfoValidations(nextInfos);\n          var nextValidationResults = {\n            errors: nextErrors,\n            infos: nextInfos,\n            valid: buildValid(nextErrors)\n          };\n          if (onValidate) onValidate(nextValidationResults);\n          return nextValidationResults;\n        });\n      } // a timeout is needed to ensure that a click event (like one on a reset\n      // button) completes prior to running the validation. without a timeout,\n      // the blur will always complete and trigger a validation prematurely\n      // The following values have been empirically tested, but 120 was\n      // selected because it is the largest value\n      // Chrome: 100, Safari: 120, Firefox: 80\n\n    }, 120);\n    return function () {\n      return clearTimeout(timer);\n    };\n  }, [buildValid, format, messages, pendingValidation, onValidate, touched, value, requiredFields]); // clear any errors when value changes\n\n  useEffect(function () {\n    if (validateOn !== 'change') setPendingValidation(undefined);\n    setValidationResults(function (prevValidationResults) {\n      var _validateForm3 = validateForm(Object.entries(validations.current).filter(function (_ref5) {\n        var n = _ref5[0];\n        return prevValidationResults.errors[n] || prevValidationResults.infos[n];\n      }), value, format, messages),\n          nextErrors = _validateForm3[0],\n          nextInfos = _validateForm3[1];\n\n      return {\n        errors: _extends({}, prevValidationResults.errors, nextErrors),\n        infos: _extends({}, prevValidationResults.infos, nextInfos)\n      };\n    });\n  }, [format, messages, touched, validateOn, value]); // There are three basic patterns of handling form input value state:\n  //\n  // 1 - form controlled\n  //\n  // In this model, the caller sets `value` and `onChange` properties\n  // on the Form component to supply the values used by the input fields.\n  // In useFormContext(), componentValue would be undefined and formValue\n  // is be set to whatever the form state has. Whenever the form state\n  // changes, we update the contextValue so the input component will use\n  // that. When the input component changes, we will call update() to\n  // update the form state.\n  //\n  // 2 - input controlled\n  //\n  // In this model, the caller sets `value` and `onChange` properties\n  // on the input components, like TextInput, to supply the value for it.\n  // In useFormContext(), componentValue is this value and we ensure to\n  // update the form state, via update(), and set the contextValue from\n  // the componentValue. When the input component changes, we will\n  // call update() to update the form state.\n  //\n  // 3 - uncontrolled\n  //\n  // In this model, the caller doesn't set a `value` or `onChange` property\n  // at either the form or input component levels.\n  // In useFormContext(), componentValue is undefined and valueProp is\n  // undefined and nothing much happens here. That is, unless the\n  // calling component needs to know the state in order to work, such\n  // as CheckBox or Select. In this case, those components supply\n  // an initialValue, which will trigger updating the contextValue so\n  // they can have access to it.\n  //\n\n  var useFormInput = function useFormInput(_ref6) {\n    var name = _ref6.name,\n        componentValue = _ref6.value,\n        initialValue = _ref6.initialValue,\n        validateArg = _ref6.validate;\n\n    var _useState5 = useState(initialValue),\n        inputValue = _useState5[0],\n        setInputValue = _useState5[1];\n\n    var formValue = name ? value[name] : undefined; // for dynamic forms, we need to track when an input has been added to\n    // the form value. if the input is unmounted, we will delete its key/value\n    // from the form value.\n\n    var keyCreated = useRef(false); // This effect is for pattern #2, where the controlled input\n    // component is driving the value via componentValue.\n\n    useEffect(function () {\n      if (name && // we have somewhere to put this\n      componentValue !== undefined && // input driving\n      componentValue !== formValue // don't already have it\n      ) {\n        setValueState(function (prevValue) {\n          var nextValue = _extends({}, prevValue);\n\n          nextValue[name] = componentValue;\n          return nextValue;\n        }); // don't onChange on programmatic changes\n      }\n    }, [componentValue, formValue, name]); // on unmount, if the form is uncontrolled, remove the key/value\n    // from the form value\n\n    useEffect(function () {\n      return function () {\n        if (keyCreated.current) {\n          keyCreated.current = false;\n          setValueState(function (prevValue) {\n            var nextValue = _extends({}, prevValue);\n\n            delete nextValue[name];\n            return nextValue;\n          });\n        }\n      };\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    [] // only run onmount and unmount\n    );\n    useEffect(function () {\n      if (validateArg) {\n        if (!validations.current[name]) {\n          validations.current[name] = {};\n        }\n\n        validations.current[name].input = validateName(validateArg);\n        return function () {\n          return delete validations.current[name].input;\n        };\n      }\n\n      return undefined;\n    }, [validateArg, name]);\n    var useValue;\n    if (componentValue !== undefined) // input component drives, pattern #2\n      useValue = componentValue;else if (valueProp && name && formValue !== undefined) // form drives, pattern #1\n      useValue = formValue;else if (formValue === undefined && name) // form has reset, so reset input value as well\n      useValue = initialValue;else useValue = inputValue;\n    return [useValue, function (nextComponentValue) {\n      if (name) {\n        // we have somewhere to put this\n        var nextTouched = _extends({}, touched);\n\n        nextTouched[name] = true;\n\n        if (!touched[name]) {\n          // don't update if not needed\n          setTouched(nextTouched);\n        }\n\n        var nextValue = _extends({}, value); // if nextValue doesn't have a key for name, this must be\n        // uncontrolled form. we will flag this field was added so\n        // we know to remove its value from the form if it is dynamically\n        // removed\n\n\n        if (!(name in nextValue)) keyCreated.current = true;\n        nextValue[name] = nextComponentValue;\n        setValueState(nextValue);\n        if (onChange) onChange(nextValue, {\n          touched: nextTouched\n        });\n      }\n\n      if (initialValue !== undefined) setInputValue(nextComponentValue);\n    }];\n  };\n\n  var useFormField = function useFormField(_ref7) {\n    var errorArg = _ref7.error,\n        infoArg = _ref7.info,\n        name = _ref7.name,\n        required = _ref7.required,\n        disabled = _ref7.disabled,\n        validateArg = _ref7.validate;\n    var error = disabled ? undefined : errorArg || validationResults.errors[name];\n    var info = infoArg || validationResults.infos[name];\n    useEffect(function () {\n      var index = requiredFields.current.indexOf(name);\n\n      if (required) {\n        if (index === -1) requiredFields.current.push(name);\n      } else if (index !== -1) requiredFields.current.splice(index, 1);\n\n      if (validateArg || required) {\n        if (!validations.current[name]) {\n          validations.current[name] = {};\n        }\n\n        validations.current[name].field = validateName(validateArg, required);\n        return function () {\n          return delete validations.current[name].field;\n        };\n      }\n\n      return undefined;\n    }, [error, name, required, validateArg, disabled]);\n    return {\n      error: error,\n      info: info,\n      inForm: true,\n      onBlur: validateOn === 'blur' ? function () {\n        return setPendingValidation(pendingValidation ? [].concat(pendingValidation, [name]) : [name]);\n      } : undefined,\n      onChange: validateOn === 'change' ? function () {\n        return setPendingValidation(pendingValidation ? [].concat(pendingValidation, [name]) : [name]);\n      } : undefined\n    };\n  };\n\n  return /*#__PURE__*/React.createElement(\"form\", _extends({\n    ref: ref\n  }, rest, {\n    onReset: function onReset(event) {\n      setPendingValidation(undefined);\n\n      if (!valueProp) {\n        setValueState(defaultValue);\n        if (onChange) onChange(defaultValue, {\n          touched: defaultTouched\n        });\n      }\n\n      setTouched(defaultTouched);\n      setValidationResults(defaultValidationResults);\n\n      if (_onReset) {\n        event.persist(); // extract from React's synthetic event pool\n\n        var adjustedEvent = event;\n        adjustedEvent.value = defaultValue;\n\n        _onReset(adjustedEvent);\n      }\n    },\n    onSubmit: function onSubmit(event) {\n      // Don't submit the form via browser form action. We don't want it\n      // if the validation fails. And, we assume a javascript action handler\n      // otherwise.\n      event.preventDefault();\n      setPendingValidation(undefined);\n\n      var _validateForm4 = validateForm(Object.entries(validations.current), value, format, messages, true),\n          nextErrors = _validateForm4[0],\n          nextInfos = _validateForm4[1];\n\n      setValidationResults(function () {\n        var nextValidationResults = {\n          errors: nextErrors,\n          infos: nextInfos,\n          // Show form's validity when clicking on Submit\n          valid: buildValid(nextErrors)\n        };\n        if (onValidate) onValidate(nextValidationResults);\n        return nextValidationResults;\n      });\n\n      if (Object.keys(nextErrors).length === 0 && _onSubmit) {\n        event.persist(); // extract from React's synthetic event pool\n\n        var adjustedEvent = event;\n        adjustedEvent.value = value;\n        adjustedEvent.touched = touched;\n\n        _onSubmit(adjustedEvent);\n      }\n    }\n  }), /*#__PURE__*/React.createElement(FormContext.Provider, {\n    value: {\n      useFormField: useFormField,\n      useFormInput: useFormInput\n    }\n  }, children));\n});\nForm.displayName = 'Form';\nForm.propTypes = FormPropTypes;\nexport { Form };"]},"metadata":{},"sourceType":"module"}